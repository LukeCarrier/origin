<?php

/**
 * Argument parser library.
 *
 * Origin.
 *
 * @author    Luke Carrier <luke@carrier.im>
 * @copyright 2013 CloudFlux
 * @license   Proprietary; all rights reserved
 */

namespace Origin\Console\Arguments;
use Origin\Console\Arguments\errors\NoSuchAction as NoSuchActionError,
    Origin\Util\StringUtil;

/**
 * A Linux-style argument parser.
 *
 * Translates an array containing the raw argument vector into an argument array based on a set of predefined rules.
 * This library is capable of interpreting long, short and positional "action" arguments.
 */
class Parser {
    /**
     * Generate help information automatically from parameters.
     *
     * @var string
     */
    const GENERATE_HELP = 1;

    /**
     * Generate usage information automatically from parameters.
     *
     * @var string
     */
    const GENERATE_USAGE = 2;

    /**
     * Action argument type.
     *
     * @var string
     */
    const ARGUMENTTYPE_ACTION = 'action';

    /**
     * Long argument type.
     *
     * @var string
     */
    const ARGUMENTTYPE_LONG = 'long';

    /**
     * Short argument type.
     *
     * @var string
     */
    const ARGUMENTTYPE_SHORT = 'short';

    /**
     * Destination parameter.
     *
     * @see \Origin\Console\Arguments\Parser::$arguments
     */
    const PARAM_DESTINATION = 0;

    /**
     * Default number of arguments parameter.
     *
     * @see \Origin\Console\Arguments\Parser::$arguments
     */
    const PARAM_NUM_ARGS = 1;

    /**
     * Help parameter.
     *
     * @see \Origin\Console\Arguments\Parser::$arguments
     */
    const PARAM_HELP = 2;

    /**
     * Required parameter.
     *
     * @see \Origin\Console\Arguments\Parser::$arguments
     */
    const PARAM_REQUIRED = 3;

    /**
     * Destination for the action (or subparser name) value.
     *
     * @var string
     */
    protected $action_destination;

    /**
     * Supplied command line argument rules.
     *
     * @var array<int, array<string, callable|string|array>>
     */
    protected $arguments;

    /**
     * Descriptive text for the host application.
     *
     * @var string
     */
    protected $description;

    /**
     * Post-help/usage text for the host application.
     *
     * @var string
     */
    protected $epilog;

    /**
     * What help/usage information to generate automatically.
     *
     * Should contain a bitmask value generated by an OR operation on the
     * GENERATE_* constants defined in this class.
     *
     * @var integer
     */
    protected $generate;

    /**
     * The name of the host program.
     *
     * @var string
     */
    protected $program;

    /**
     * Destination for subparser objects.
     *
     * @var string
     */
    protected $subparser_destination;

    /**
     * All registered subparsers.
     *
     * @var array<string, Parser>
     */
    protected $subparsers = [];

    /**
     * Custom usage text.
     *
     * If defined, will override the text automatically generated if GENERATE_USAGE is also enabled.
     *
     * @var string
     */
    protected $usage;

    /**
     * Initialiser.
     *
     * @param string  $program               The name of the program, generally assumed to be the first value in the
     *                                       argument vector.
     * @param string  $usage                 A one-liner of usage information about the program's parameter order.
     * @param string  $description           A lengthier description of the program's purpose and functionality.
     * @param string  $epilog                Closing information about the program.
     * @param integer $generate              A bitmask field defining which help information should be generated. This
     *                                       parameter's value should be constructed using the GENERATE_* constants.
     * @param string  $action_destination    The index within the resulting argument array which should be populated
     *                                       with the positional action value.
     * @param string  $subparser_destination The index within the resulting argument array at which the matching action
     *                                       subparser should be set.
     */
    public function __construct($program=null, $usage=null, $description=null, $epilog=null, $generate=null,
                                $action_destination=null, $subparser_destination=null) {
        $this->setProgram($program);
        $this->setUsage($usage);
        $this->setDescription($description);
        $this->setEpilog($epilog);
        $this->setGenerate($generate);
        $this->setActionDestination($action_destination);
        $this->setSubparserDestination($subparser_destination);

        $this->arguments = [
            static::ARGUMENTTYPE_ACTION => [],
            static::ARGUMENTTYPE_LONG   => [],
            static::ARGUMENTTYPE_SHORT  => [],
        ];
    }

    /**
     * Add a positional action argument.
     *
     * @param string $name The name of the action.
     *
     * @return void
     */
    public function addAction($name) {
        $this->arguments[static::ARGUMENTTYPE_ACTION][] = $name;
    }

    /**
     * Add a subparser.
     *
     * @param string $name The name of the action.
     *
     * @return Parser The newly added subparser object.
     */
    public function addSubparser($name) {
        $this->addAction($name);
        $this->subparsers[$name] = new static();

        return $this->subparsers[$name];
    }

    /**
     * Add an argument.
     *
     * @param string $long        The long name of the argument.
     * @param string $short       The short name of the argument.
     * @param string $destination The index within the resulting argument array which should be populated with the value
     *                            or presence of this argument.
     * @param string $num_args    The number of arguments which the argument accept.
     * @param string $help        Some explanatory text and usage information about the command.
     * @param string $required    Whether or not this parameter is considered to be required.
     *
     * @return void
     */
    public function addArgument($long, $short=null, $destination=null, $num_args=0, $help=null, $required=false) {
        if ($destination === null) {
            $destination = $long;
        }

        $argument = [
            static::PARAM_DESTINATION => $destination,
            static::PARAM_NUM_ARGS    => $num_args,
            static::PARAM_HELP        => $help,
            static::PARAM_REQUIRED    => $required,
        ];

        $this->arguments[static::ARGUMENTTYPE_LONG][$long] = $argument;

        if ($short !== null) {
            $this->arguments[static::ARGUMENTTYPE_SHORT][$short] = $argument;
        }
    }

    /**
     * Parse the command line arguments, raising on any unknown arguments.
     *
     * @param array $argument_vector The array containing the CLI arguments; generally $argv.
     *
     * @return ArgumentArray The values for the arguments, as extracted from the supplied argument vector.
     *
     * @todo Subclass exception so we can output useful error condition information.
     */
    public function parseArguments($argument_vector) {
        list($result, $unknown) = $this->parseKnownArguments($argument_vector);

        if (count($unknown) > 0) {
            throw new \Exception('encountered unknown elems');
        }

        return $result;
    }

    /**
     * Parse only known arguments, continuing despite unknown arguments.
     *
     * @param array $argument_vector The array containing the CLI arguments; generally $argv.
     *
     * @return mixed[] An array continuing two values. Index 0 contains the ArgumentArray object with the
     *                 values/presence of all of the added arguments. Index 1 contains all of the unknown arguments
     *                 encountered in the argument vector.
     */
    public function parseKnownArguments($argument_vector) {
        $result  = [];
        $unknown = [];
        
        array_shift($argument_vector);

        while ($raw_argument = array_shift($argument_vector)) {
            if (StringUtil::startsWith($raw_argument, '-')) {
                $value = true;

                if (StringUtil::contains($raw_argument, '=')) {
                    list($raw_argument, $next_argument) = explode('=', $raw_argument, 2);
                    array_unshift($argument_vector, $next_argument);
                }

                list($argument_type, $argument_name) = static::parseArgumentName($raw_argument);
                if (array_key_exists($argument_name,
                                     $this->arguments[$argument_type])) {
                    $argument = $this->arguments[$argument_type][$argument_name];
                    $num_args = $argument[static::PARAM_NUM_ARGS];
                    if ($num_args > 0) {
                        $value = array_splice($argument_vector, 0, $num_args);
                        if (count($value) < $num_args) {
                            throw new \Exception('not enough arguments');
                        }
                        if ($num_args === 1) {
                            $value = $value[0];
                        }
                    }
                    $result[$argument[static::PARAM_DESTINATION]] = $value;
                } else {
                    $unknown[] = $raw_argument;
                }
            } elseif (in_array($raw_argument, $this->arguments[static::ARGUMENTTYPE_ACTION])) {
                if (array_key_exists($this->action_destination, $result)) {
                    throw new \Exception('attempted to set action twice');
                }

                if (array_key_exists($raw_argument, $this->subparsers)) {
                    array_unshift($argument_vector, $raw_argument);
                    $subparser = $this->subparsers[$raw_argument];
                    list($subparser_arguments, $argument_vector) = $subparser->parseKnownArguments($argument_vector);

                    $result[$this->subparser_destination] = $subparser_arguments;
                }

                $result[$this->action_destination] = $raw_argument;
            } else {
                $unknown[] = $raw_argument;
            }
        }

        return [
            $result,
            $unknown,
        ];
    }

    /**
     * Print the help for the program.
     *
     * @return void
     */
    public function printHelp() {
    }

    /**
     * Set the destination for the action parameter.
     *
     * @param string $action_destination The index within the resulting argument array which should be populated with
     *                                   the positional action value.
     *
     * @return void
     */
    public function setActionDestination($action_destination=null) {
        $this->action_destination = $action_destination ?: 'action';
    }

    /**
     * Set the program description.
     *
     * @param string $description A lengthier description of the program's purpose and functionality.
     *
     * @return void
     */
    public function setDescription($description=null) {
        $this->description = $description ?: '';
    }

    /**
     * Set the program epilog.
     *
     * @param string $epilog Closing information about the program.
     *
     * @return void
     */
    public function setEpilog($epilog=null) {
        $this->epilog = $epilog ?: '';
    }

    /**
     * Set the types of help which should be generated.
     *
     * @param integer $generate A bitmask field defining which help information should be generated. This parameter
     *                          should be constructed using the GENERATE_* constants.
     *
     * @return void
     */
    public function setGenerate($generate=null) {
        $this->generate = $generate ?: (static::GENERATE_HELP | static::GENERATE_USAGE);
    }

    /**
     * Set the program name.
     *
     * @param string $program The name of the program, generally assumed to be the first value in the argument vector.
     *
     * @return void
     */
    public function setProgram($program=null) {
        global $argv;

        $this->program = $program ?: $argv[0];
    }

    /**
     * Set the destination of the subparser within the result.
     *
     * @param string $subparser_destination The index within the resulting argument array at which the matching action
     *                                      subparser should be set.
     *
     * @return void
     */
    public function setSubparserDestination($subparser_destination=null) {
        $this->subparser_destination = $subparser_destination ?: 'subparser';
    }

    /**
     * Set the program usage information.
     *
     * @param string $usage A one-liner of usage information about the program's parameter order.
     *
     * @return void
     */
    public function setUsage($usage=null) {
        $this->usage = $usage ?: '';
    }

    /**
     * From a raw CLI argument, guess its type and its type-specific name.
     *
     * @param string $argument The raw argument from the argument vector.
     *
     * @return string[] An array containing the argument's type at the first index (which will be equal to one of the
     *                  ARGUMENTTYPE_* constants), and the argument's name minus the type prefix at the second.
     */
    public static function parseArgumentName($argument) {
        $argument_type = (StringUtil::startsWith($argument, '--'))
                ? static::ARGUMENTTYPE_LONG : static::ARGUMENTTYPE_SHORT;

        $start_position = ($argument_type === static::ARGUMENTTYPE_LONG) ? 2 : 1;
        $argument_name = substr($argument, $start_position);

        return [
            $argument_type,
            $argument_name,
        ];
    }

    /**
     * Get the type of an argument based on the format of its name.
     *
     * @param string $argument The name of the argument.
     *
     * @return integer The value of the ARGUMENTTYPE_* constant that corresponds with the type of the argument.
     */
    public static function getArgumentType($argument) {
        if (substr($argument, 0, 2) == '--') {
            $result = static::ARGUMENTTYPE_LONG;
        } elseif (substr($argument, 0, 1) == '-') {
            $result = static::ARGUMENTTYPE_SHORT;
        } else {
            $result = static::ARGUMENTTYPE_ACTION;
        }

        return $result;
    }

    /**
     * Gets the supplied command line argument rules.
     *
     * @return array<int, array<string, callable|string|array>>
     */
    public function getArguments() {
        return $this->arguments;
    }
}
